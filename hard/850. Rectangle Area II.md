
# 850. Rectangle Area II

## Question

We are given a list of (axis-aligned)  `rectangles`. Each  `rectangle[i] = [xi1, yi1, xi2, yi2]` , where  `(xi1, yi1)`  are the coordinates of the bottom-left corner, and  `(xi2, yi2)`  are the coordinates of the top-right corner of the  `ith`  rectangle.

Find the total area covered by all  `rectangles`  in the plane. Since the answer may be too large, return it  **modulo**  `109  + 7`.

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png)

**Input:** rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
**Output:** 6
**Explanation:** As illustrated in the picture.

**Example 2:**

**Input:** rectangles = [[0,0,1000000000,1000000000]]
**Output:** 49
**Explanation:** The answer is 1018 modulo (109 + 7), which is (109)2 = (-7)2 = 49.

**Constraints:**

- `1 <= rectangles.length <= 200`
- `rectanges[i].length = 4`
- `0 <= rectangles[i][j] <= 109`
- The total area covered by all rectangles will never exceed  `263  - 1`  and thus will fit in a  **64-bit**  signed integer.

## Solution

### Approach 1: Line Sweep

#### Intuition

The main idea is to sweep through x axies, and using open interverals of y axies to calculate the spave up to the sweeped x values.

We also sweep through open intervals to make sure not to double count.

#### Algorithm

1. Get the events that we need to do calculation and update open intervals
2. For each event, realize space and update (and sort if needed) open interval
3. Return the total realized area at the end of events

#### Code

```python
class Solution:
    def rectangleArea(self, rectangles: List[List[int]]) -> int:
        MOD = 10**9 + 7
        INT_MIN = -2**32
        # convert list of rectangles to events
        events = [] # tuple of x, isOpen, y1, y2
        for x1, y1, x2, y2 in rectangles:
            events.append((x1, True, y1, y2))
            events.append((x2, False, y1, y2))
        events.sort(key=lambda x: (x[0]))
        # helper to do total interval via sweep
        def gain_area(xMoved):
            area = 0
            prev = INT_MIN
            for l, r in open_intervals:
                # dont update prev if we already
                # counted to a prev larger than l
                prev = max(prev, l)
                # ignore negative area which is
                # the part we already counted
                area += max(0, (r - prev) * xMoved)
                # move to the end of currinterval
                prev = max(r, prev)
            return area
            
        # sweep line to realize area
        area = 0
        prev = INT_MIN
        open_intervals = []
        for event in events:
            curr, isOpen, y1, y2 = event
            area += gain_area(curr - prev)
            if isOpen:
                open_intervals.append((y1, y2))
                open_intervals.sort()
            else:
                open_intervals.remove((y1, y2))
            prev = curr
        return area%MOD
```

#### Complexity Analysis

- **Time Complexity:**  `O(n^2logn)`,
  - `O(n)`, to loop through events
  - `O(nlogn)`, to sort open intervals as the most expensive operation in loop

- **Space Complexity:**  `O(n)`, to store all visited nodes in hashmap
