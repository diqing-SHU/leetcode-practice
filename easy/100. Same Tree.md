# 100. Same Tree

  

## Question:


Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

**Example 1:**

**Input:**     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

**Output:** true

**Example 2:**

**Input:**     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

**Output:** false

**Example 3:**

**Input:**     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

**Output:** false

  
  

## Solution:

  

**Approach 1: Recursion**
Check if `p` and `q` nodes are not `None`, and their values are equal. If all checks are OK, do the same for the child nodes recursively.
  

```python

class  Solution:

def  isSameTree(self, p: TreeNode, q: TreeNode) -> bool:

if  not q or  not p:

if  not q and  not p:

return  True

else:

return  False

if p.val != q.val:

return  False

else:

return  self.isSameTree(p.left, q.left) and  self.isSameTree(p.right, q.right)

```

**Complexity Analysis**

  

TC:O(n) all nodes are visited

  

SC:O(log(N)) in the best case of completely balanced tree and O(N) in the worst case of completely unbalanced tree, to keep a recursion stack.

**Approach 2:  Iteration**
Start from the root and then at each iteration pop the current node out of the deque. Then do the same checks as in the approach 1 :

-   `p`  and  `p`  are not  `None`,
    
-   `p.val`  is equal to  `q.val`,
    

and if checks are OK, push the child nodes. (using deque)
  

```python

class  Solution:

def  isSameTree(self, p: TreeNode, q: TreeNode) -> bool:

if  not q or  not p:

if  not q and  not p:

return  True

else:

return  False

if p.val != q.val:

return  False

else:

return  self.isSameTree(p.left, q.left) and  self.isSameTree(p.right, q.right)

```

**Complexity Analysis**

  

TC:O(n) all nodes are visited

  

SC:O(log(N)) in the best case of completely balanced tree and O(N) in the worst case of completely unbalanced tree, to keep a recursion stack.