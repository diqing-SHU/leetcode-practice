
# 926. Flip String to Monotone Increasing

## Question

A binary string is monotone increasing if it consists of some number of  `0`'s (possibly none), followed by some number of  `1`'s (also possibly none).

You are given a binary string  `s`. You can flip  `s[i]`  changing it from  `0`  to  `1`  or from  `1`  to  `0`.

Return  _the minimum number of flips to make_ `s` _monotone increasing_.

**Example 1:**

**Input:** s = "00110"
**Output:** 1
**Explanation:** We flip the last digit to get 00111.

**Example 2:**

**Input:** s = "010110"
**Output:** 2
**Explanation:** We flip to get 011111, or alternatively 000111.

**Example 3:**

**Input:** s = "00011000"
**Output:** 2
**Explanation:** We flip to get 00000000.

**Constraints:**

- `1 <= s.length <= 105`
- `s[i]`  is either  `'0'`  or  `'1'`.

## Solution

### Approach 1: DP

#### Intuition

Based on description of the question, to create a monotone Increasing binary string, we only have 3 senarios: all 0s, all 1s, or start with 0(s) and end with 1(s).

The flips for first and second scenario are easy to calculate. For third scenario, we can keep 2 dp arrays for flips to 0 from start and flips to 1 from end. The flips at one point if flip 0 + flip 1 for before and after that point.

#### Algorithm

1. One pass and create the 2 dp arrays
2. One pass all possible combinations with the 2 dp arrays
3. Return the minimum flips

#### Code

```python
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        flipZero, flipOne = [0 for i in range(len(s))], [0 for i in range(len(s))]
        if s[0] == '1':
            flipZero[0] = 1
        if s[len(s)-1] == '0':
            flipOne[len(s)-1] = 1
        for i in range(1, len(s)):
            flipZero[i] = flipZero[i-1]
            flipOne[len(s)-1-i] = flipOne[len(s)-i]
            if s[i] == '1':
                flipZero[i] += 1
            if s[len(s)-1-i] == '0':
                flipOne[len(s)-1-i] += 1
        res = len(s)
        for i in range(-1, len(s)):
            if i == -1:
                res = min(res, flipOne[0])
            elif i == len(s)-1:
                res = min(res, flipZero[len(s)-1])
            else:
                res = min(res, flipZero[i]+flipOne[i+1])
        return res
```

#### Complexity Analysis

- **Time Complexity:**  `O(n)`, Three one passes

- **Space Complexity:**  `O(n)`, Our dp arrays
